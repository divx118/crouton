#!/bin/sh
# This script will be used as an action script of the udev rule
# for mounting ext2/3/4 partitions on USB or SD-cards.
# and as setting up the udev rule to trigger it.

# check if script is run as root
uid=`id -u $USERNAME`
if [ $uid -ne 0 ]; then
  echo "$0 must be run as root"
  exit 1
fi

# Turn on/off verbose debugging by uncomment/comment
#set -x
#exec 2>/var/log/mountextfs.log
APPLICATION="${0##*/}"
BINDIR="`dirname "\`readlink -f "$0"\`"`"
# Default mount options to specify in the udev rule.
MOUNT_OPTIONS="rw,dirsync,nosuid,nodev,noexec,relatime"
USAGE="$APPLICATION [options] name [...]

Mounts one or more ext2/3/4 USB devices or SD-cards on top of a loop device
which will then show up in the chromeos Files app.

Options:
    -d DEVICE        Kernel device name for example sdb ,sdc ,sdd etc.
                     Normally passed by the UDEV rule.
    -m MOUNT_OPTIONS Mount options for the partitions. Default: $MOUNT_OPTIONS.
    -s               Setup the UDEV rule."
SETUP=''

# Process arguments
while getopts 'd:m:s' f; do
    case "$f" in
    d) KERNEL_DEVNAME="$OPTARG";;
    m) MOUNT_OPTIONS="$OPTARG";;
    s) SETUP='y';;
    \?) echo "$USAGE"
        exit 0;;
    esac
done
# Magic seems to be happening here.
mount_extfs() {
  mountextfs_tmp="/tmp/mount-extfs/"
  mkdir -p $mountextfs_tmp

  # Setting up the loop devices
  blkid /dev/$KERNEL_DEVNAME*|while read line;do
    dev_part=`echo $line |cut -d ":" -f 1`
    # The variable part_prop will look like
    # LABEL="PartLabel" UUID="uuid" TYPE="fstype" PARTUUID="PartUuid"
    # Replace the spaces with ; to eval the string.
    part_prop=`echo $line |cut -d ":" -f 2-|sed 's/\" /\"\;/g'`
    # Delete variables we use.
    unset LABEL TYPE PARTUUID
    eval $part_prop
    if [ "x${TYPE##ext[2-4]}" != "x$TYPE" ];then
      # Use PARTUUID when we have no label.
      if [ -z "$LABEL" ];then
        LABEL=$PARTUUID
      fi
      # Be sure the file is gone else mkfs.vfat will fail.
      rm -f "$mountextfs_tmp${dev_part##*/}"
      # Create loop file.
      mkfs.vfat -C "$mountextfs_tmp${dev_part##*/}" 34 -n "$LABEL"
      loop_device=`losetup -f --show $mountextfs_tmp${dev_part##*/}`
      # Create a tmp file to pause the unmount-loop script
      # and to store the loop devices, partition devices we
      # used.
      echo $loop_device","$dev_part >> $mountextfs_tmp"part_"$KERNEL_DEVNAME
      # Send the loop to CrosDisks to be mounted.
      dbus-send --print-reply --system --dest=org.chromium.CrosDisks \
        /org/chromium/CrosDisks org.chromium.CrosDisks.Mount \
        string:$loop_device string:"" array:string:"ro"
    fi
  done
  # We will check at most 5 seconds /proc/mounts which should be
  # enough time for crossdisks to mount the loops.
  # to know if the partitions are mounted.
  # Mounting the ext2/3/4 partitions.
  j=0
  while [ "x`cat $mountextfs_tmp"part_"$KERNEL_DEVNAME`" != "x" -a $j -lt 6 ];do
    # loop through the loop devices we created.
    for line in `cat $mountextfs_tmp"part_"$KERNEL_DEVNAME`;do
      loop_device=`echo $line|cut -d "," -f 1`
      dev_part=`echo $line|cut -d "," -f 2`
      # Get the mount directory from /proc/mounts CrosDisks
      # created.
      mount_point=`cat /proc/mounts|grep -v \
        "/run/crouton/mnt/stateful_partition" \
        |grep $loop_device|cut -d " " -f 2 \
        |sed 's/\\\040/ /g'`
      # Mounting the partition on top of the loop
      mount $dev_part "$mount_point" -o "$MOUNT_OPTIONS" || continue
      # Remove loop_device from the tmp file
      loop_device=`echo $loop_device|sed 's/\//\\\\\//g'`
      sed --in-place "/$loop_device/d" $mountextfs_tmp"part_"$KERNEL_DEVNAME
    done
    # Try x times to give CrosDisks some time.
    j=$(( $j+1 ))
    sleep 1
  done
  # cleanup the tmp file we use, this is also used to pause
  # the unmount-loop script to prevent newly created loop devices
  # to unmount when the ext2/3/4 partition is not mounted yet.
  # Start the unmount-loop script if it isn't already running.
  # TODO: add a check if we can't mount a device, tmp file will
  # not be empty in such case.
  if [ -f $mountextfs_tmp"part_"$KERNEL_DEVNAME ];then
    rm $mountextfs_tmp"part_"$KERNEL_DEVNAME
    if [ "x`ps -aux|grep unmount-loop|grep -v grep`" = "x" ];then
      /usr/local/bin/unmount-loop &
    fi
  fi
}

setup_udevrule() {
  rules_file="/run/udev/rules.d/10-mountextfs.rules" 
  mkdir -p "`dirname "$rules_file"`"
  # Create the file, we don't care if it already exists. Just
  # replace the old one so we can easily update the mount options.
  echo "# udev rule for mounting ext2/3/4 formatted usb devices and sd-cards" \
    > "$rules_file"
  echo "ACTION==\"add\", SUBSYSTEM==\"block\", KERNEL==\"sd?|mmcblk?\", \
    RUN+="\"$BINDIR/$APPLICATION -d %k -m "$MOUNT_OPTIONS"\""" >> "$rules_file"
  # Update the udev rules 
  udevadm control --reload-rules
}
# Mount or setting up.
if [ -z "$SETUP" ];then
  mount_extfs
else
  setup_udevrule 
fi
exit 0


