#!/bin/sh
# This script will be used as an action script of the udev rule
# for mounting ext2/3/4 partitions on USB or SD-cards.
# and as setting up the udev rule to trigger it.

# check if script is run as root
uid=`id -u $USERNAME`
if [ $uid -ne 0 ]; then
  echo "$0 must be run as root"
  exit 1
fi

# Turn on/off verbose debugging by uncomment/comment
#set -x
#exec 2>/var/log/mountextfs.log

# Use this to create a unique name for the loop file.
kernel_devname=$2
# mount options to specify in the udev rule.
mount_options=$3
if [ -z $mount_options ];then
  mount_options="rw,dirsync,nosuid,nodev,noexec,relatime"
fi
loops=""
# Magic seems to be happening here.
mount_extfs() {
  loopfile_path="/usr/local"
  mkdir $loopfile_path/dev
  # Setting up the loop devices
  blkid /dev/$kernel_devname?|while read line;do
    dev_part=`echo $line |cut -d ":" -f 1`
    # The variable part_prop will look like
    # LABEL="PartLabel" UUID="uuid" TYPE="fstype" PARTUUID="PartUuid"
    # Replace the spaces with ; to eval the string.
    part_prop=`echo $line |cut -d ":" -f 2-|sed 's/\" /\"\;/g'`
    # Delete variables we use.
    unset LABEL TYPE PARTUUID
    eval $part_prop
    if [ "${TYPE##ext*}" != "$TYPE" ];then
      # Creating loop file 
      dd if=/dev/zero of=$loopfile_path$dev_part bs=1KB count=128
      # Use PARTUUID when we have no label.
      if [ -z "$LABEL" ];then
        LABEL=$PARTUUID
      fi
      # FIXME: Replace spaces with underscore, mounting does not
      # work correctly.
      # We have a simular problem when using identical labels for
      # the partitions. We solve that by prefixing it with the last
      # 2 characters of the device partition name.
      LABEL=`echo $dev_part|cut -d "/" -f 3| \
        sed 's/sd//g'`"."`echo $LABEL|sed 's/ /_/g'`
      mkfs.vfat $loopfile_path$dev_part -n "$LABEL"
      loop_device=`losetup -f --show $loopfile_path$dev_part`
      # Create a tmp file to pause the unmount-loop script
      # and to store the loop devices, partition devices we
      # used.
      echo $loop_device","$dev_part >> /tmp/$kernel_devname
      # Send the loop to CrosDisks to be mounted.
      dbus-send --print-reply --system --dest=org.chromium.CrosDisks \
        /org/chromium/CrosDisks org.chromium.CrosDisks.Mount \
        string:$loop_device string:"" array:string:"ro"
    fi
  done
  # TODO: check if 9 seconds will be enough or too much
  # to know if the partitions are mounted.
  # Mounting the ext2/3/4 partitions.
  j=0
  while [ "x`cat /tmp/$kernel_devname`" != "x" -a $j -lt 10 ];do
    # loop through the loop devices we created.
    for line in `cat /tmp/$kernel_devname`;do
      loop_device=`echo $line|cut -d "," -f 1`
      dev_part=`echo $line|cut -d "," -f 2`
      # Get the mount directory from /proc/mounts CrosDisks
      # created.
      mount_point=`cat /proc/mounts|grep -v \
        "/run/crouton/mnt/stateful_partition" \
        |grep $loop_device|cut -d " " -f 2 \
        |sed 's/\\\040/ /g'`
      # Mounting the partition on top of the loop
      mount $dev_part "$mount_point" -o "$mount_options"
      # Remove loop_device from the tmp file
      loop_device=`echo $loop_device|sed 's/\//\\\\\//g'`
      sed --in-place "/$loop_device/d" /tmp/$kernel_devname
    done
    # Try x times to give CrosDisks some time.
    j=$(( $j+1 ))
    sleep 1
  done
  # cleanup the tmp file we use, this is also used to pause
  # the unmount-loop script to prevent new created loop devices
  # to unmount when the ext2/3/4 partition is not mounted yet.
  if [ -f /tmp/$kernel_devname ];then
    rm /tmp/$kernel_devname
    if [ "x`ps -aux|grep unmount-loop|grep -v grep`" = "x" ];then
      /usr/local/bin/unmount-loop &
    fi
  fi
  exit 0

}

setup_udevrule() {
  mkdir -p /run/udev/rules.d
  rules_file="/run/udev/rules.d/10-mountextfs.rules" 
  if [ ! -f "$rules_file" ];then
    echo "# udev rule for mounting ext2/3/4 formatted usb devices and sd-cards" \
      > "$rules_file"
    echo 'ACTION=="add", SUBSYSTEM=="block", KERNEL=="sd?", \
      RUN+="/usr/local/bin/mount-extfs start %k"' >> "$rules_file"
    # Update the udev rules 
    udevadm control --reload-rules
  else
    echo "$rules_file already exists nothing todo."
    exit 0 
  fi
}
# Just for now everything in one script file.
case "$1" in
  start)
    mount_extfs
    ;;
  setup)
    setup_udevrule 
    echo "done" 
    exit 0 
    ;;

  *)
    echo "Usage: $0 {setup}"
esac
exit 0

